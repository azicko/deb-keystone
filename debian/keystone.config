#!/bin/sh

set -e

. /usr/share/debconf/confmodule

### Reading of values in the keystone config file       ###
### and setting default for dbconfig-common accordingly ###
KEY_CONF=/etc/keystone/keystone.conf

if [ -e "${KEY_CONF}" ] ; then
	KEY_CONF_AUTH_TOKEN=`grep -E "^([ \t])*admin_token([ \t])*=([ \t])*" ${KEY_CONF} | awk '{print $3}'`
	if [ -n "${KEY_CONF_AUTH_TOKEN}" ] ; then
		db_set keystone/auth-token ${KEY_CONF_AUTH_TOKEN}
	fi
fi
db_input high keystone/auth-token || true
db_input high keystone/configure_db || true
db_input high keystone/admin-username || true
db_input high keystone/admin-email || true
db_input high keystone/admin-password || true
db_input high keystone/admin-password-confirm || true
db_input medium keystone/admin-rolename || true
db_input medium keystone/admin-tenantname || true
db_go

have_pass=false
while [ "$have_pass" != "true" ] ; do
    db_get keystone/admin-password || true
    p1=$RET
    db_get keystone/admin-password-confirm || true
    p2=$RET
    if [ -n "$p1" ] && [ "$p1" = "$p2" ] ; then
	have_pass=true
	continue
    fi

    db_reset keystone/admin-password
    db_fset keystone/admin-password seen false
    db_reset keystone/admin-password-confirm
    db_fset keystone/admin-password-confirm seen false

    db_input high keystone/passwords-do-not-match || true
    db_input high keystone/admin-password || true
    db_input high keystone/admin-password-confirm || true
    db_go || true
done

db_get keystone/configure_db
if [ "$RET" = "true" ] && [ -f /usr/share/dbconfig-common/dpkg/config ] ; then
	. /usr/share/dbconfig-common/dpkg/config
	if [ -e "${KEY_CONF}" ] ; then
		KEY_CONF_DB_CON_INFO=`grep -E "^([ \t])*connection([ \t])*=([ \t])*" ${KEY_CONF} | awk '{print $3}'`
	else
		KEY_CONF_DB_CON_INFO="sqlite:///var/lib/keystone/keystonedb"
	fi
	KEY_CONF_DB_TYPE=${KEY_CONF_DB_CON_INFO%%:*}
	# If we have an undefined SQL type, we go back to a more sane default (eg: SQLite)
	if [ "${KEY_CONF_DB_TYPE}" != "sqlite" ] && [ "${KEY_CONF_DB_TYPE}" != "mysql" ] && [ "${KEY_CONF_DB_TYPE}" != "pgsql" ] ; then
		KEY_CONF_DB_CON_INFO="sqlite:///var/lib/keystone/keystonedb"
		KEY_CONF_DB_TYPE="sqlite"
	fi
	if [ "${KEY_CONF_DB_TYPE}" = "sqlite" ] ; then
		# This is the invalid default in the etc/keystone.conf in the source package
		if [ "${KEY_CONF_DB_CON_INFO}" = "sqlite:///keystone.db" ] ; then
			KEY_CONF_DB_CON_INFO="sqlite:///var/lib/keystone/keystonedb"
		fi

		KEY_CONF_DB_PATH=${KEY_CONF_DB_CON_INFO#sqlite://}
		if [ -z "${KEY_CONF_DB_PATH}" ] ; then
			KEY_CONF_DB_PATH=/var/lib/keystone/keystonedb
		fi
		dbc_basepath=`dirname "${KEY_CONF_DB_PATH}"`
		dbc_dbname=`basename "${KEY_CONF_DB_PATH}"`
		dbc_dbtypes="sqlite3, mysql, pgsql"
	else
		# Later, the postinst does: mysql://$dbc_dbuser:$dbc_dbpass@${dbc_dbserver:-localhost}$dbport/$dbc_dbname
		# so we are supposed to parse that if it exists
		KEY_CONF_ADDR=${KEY_CONF_DB_CON_INFO#*sql://}
		KEY_CONF_BEFORE_AT=${KEY_CONF_ADDR%%@*}
		KEY_CONF_AFTER_AT=${KEY_CONF_ADDR#*@}

		KEY_CONF_USER=${KEY_CONF_BEFORE_AT%%:*}
		KEY_CONF_PASS=${KEY_CONF_BEFORE_AT#*:}
		KEY_CONF_SERVER_PORT=${KEY_CONF_AFTER_AT%%/*}
		KEY_CONF_DB_NAME=${KEY_CONF_AFTER_AT#*/}

		KEY_CONF_SERVER=${KEY_CONF_SERVER_PORT%%:*}
		case "${KEY_CONF_SERVER_PORT}" in
		    *:*)
			KEY_CONF_SERVER=${KEY_CONF_SERVER_PORT#*:}
			;;
		    *)
			KEY_CONF_PORT=""
		esac

		if [ -n "${KEY_CONF_USER}" ] && [ -n "${KEY_CONF_PASS}" ] && [ -n "${KEY_CONF_SERVER}" ] && [ -n "${KEY_CONF_DB_NAME}" ] ; then
			dbc_dbuser=${KEY_CONF_USER}
			dbc_dbpass=${KEY_CONF_PASS}
			dbc_dbserver=${KEY_CONF_SERVER}
			dbc_dbport=${KEY_CONF_PORT}
			if [ "${KEY_CONF_DB_NAME}" = "keystonedb" ] ; then
				dbc_dbname="keystone"
			else
				dbc_dbname=${KEY_CONF_DB_NAME}
			fi
		fi
		if [ "${KEY_CONF_DB_TYPE}" = "mysql" ] ; then
			dbc_dbtypes="mysql, pgsql, sqlite3"
		else
			dbc_dbtypes="pgsql, mysql, sqlite3"
		fi
		db_authmethod_user="password"
	fi
	dbc_go keystone $@
fi
