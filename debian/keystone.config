#!/bin/sh

set -e

. /usr/share/debconf/confmodule

### Reading of values in the keystone config file       ###
### and setting default for dbconfig-common accordingly ###
KEY_CONF=/etc/keystone/keystone.conf

if [ -e "${KEY_CONF}" ] ; then
	KEY_CONF_AUTH_TOKEN=`grep -E "^([ \t])*admin_token([ \t])*=([ \t])*" ${KEY_CONF} | awk '{print $3}'`
	if [ -n "${KEY_CONF_AUTH_TOKEN}" ] ; then
		db_set keystone/auth-token ${KEY_CONF_AUTH_TOKEN}
	fi
fi
db_input high keystone/auth-token || true
db_input high keystone/configure_db || true
db_input high keystone/admin-username || true
db_input high keystone/admin-email || true
db_input high keystone/admin-password || true
db_input high keystone/admin-password-confirm || true
db_input medium keystone/admin-rolename || true
db_input medium keystone/admin-tenantname || true
db_go

gen_password () {
    i=$(dd if=/dev/random bs=64 count=1 2>|/dev/null | md5sum)
    echo ${i% *}
}

parse_connstring () {
    local ADDR BEFORE_AT AFTER_AT SERVER_PORT CONN_STRING PKG_NAME

    CONN_STRING=$1
    PKG_NAME=$2

    PARSED_DB_TYPE=${CONN_STRING%%:*}
    
    # If we have an undefined SQL type, we go back to a more sane default (eg: SQLite)
    case "${PARSED_DB_TYPE}" in
	sqlite|mysql|pgsql)
	    ;;
	postgresql*)
	    PARSED_DB_TYPE=pgsql
	    ;;
	*)
	    CONN_STRING="sqlite:///var/lib/${PKG_NAME}/${PKG_NAME}db"
	    PARSED_DB_TYPE="sqlite"
    esac
    if [ "${DB_TYPE}" = "sqlite" ] ; then
	if [ "${CONN_STRING}" = "sqlite:///${PKG_NAME}.db" ] ; then
	    CONN_STRING="sqlite:///var/lib/${PKG_NAME}/${PKG_NAME}db"
	fi
	
	PARSED_DB_PATH=${CONN_STRING#sqlite://}
	if [ -z "${PARSED_DB_PATH}" ] ; then
	    PARSED_DB_PATH=/var/lib/${PKG_NAME}/${PKG_NAME}db
	fi
    else
	ADDR=${CONN_STRING#*sql://}
	BEFORE_AT=${ADDR%%@*}
	AFTER_AT=${ADDR#*@}
	SERVER_PORT=${AFTER_AT%%/*}
	
	PARSED_USER=${BEFORE_AT%%:*}
	PARSED_PASS=${BEFORE_AT#*:}
	PARSED_DB_NAME=${AFTER_AT#*/}
	PARSED_SERVER=${SERVER_PORT%%:*}
	case "${SERVER_PORT}" in
	    *:*)
		PARSED_PORT=${SERVER_PORT#*:}
		;;
	    *)
		PARSED_PORT=""
	esac
    fi
}    

db_get keystone/auth-token
if [ -z "$RET" ] ; then
    db_set keystone/auth-token $(gen_password)
fi

have_pass=false
while [ "$have_pass" != "true" ] ; do
    db_get keystone/admin-password || true
    p1=$RET
    db_get keystone/admin-password-confirm || true
    p2=$RET
    if [ -n "$p1" ] && [ "$p1" = "$p2" ] ; then
	have_pass=true
	continue
    fi

    db_fget keystone/admin-password seen || true
    if [ "$RET" != "true" ] ; then
	p=$(gen_password)
	db_set keystone/admin-password $p
	db_set keystone/admin-password-confirm $p
	have_pass=true
	continue
    fi

    db_reset keystone/admin-password
    db_fset keystone/admin-password seen false
    db_reset keystone/admin-password-confirm
    db_fset keystone/admin-password-confirm seen false

    db_input high keystone/passwords-do-not-match || true
    db_input high keystone/admin-password || true
    db_input high keystone/admin-password-confirm || true
    db_go || true
done

db_get keystone/configure_db
if [ "$RET" = "true" ] && [ -f /usr/share/dbconfig-common/dpkg/config ] ; then
	. /usr/share/dbconfig-common/dpkg/config
	if [ -e "${KEY_CONF}" ] ; then
		CON_INFO=`grep -E "^([ \t])*connection([ \t])*=([ \t])*" ${KEY_CONF} | awk '{print $3}'`
	else
		CON_INFO=""
	fi

	parse_connstring "$CON_INFO" keystone
	
	dbc_dbtype=${PARSED_DB_TYPE}
	if [ "${PARSED_DB_TYPE}" = "sqlite" ] ; then
		dbc_basepath=`dirname "${PARSED_DB_PATH}"`
		dbc_dbname=`basename "${PARSED_DB_PATH}"`
		dbc_dbtypes="sqlite3, mysql, pgsql"
	else
		if [ -n "${PARSED_USER}" ] && [ -n "${PARSED_PASS}" ] && [ -n "${PARSED_SERVER}" ] && [ -n "${PARSED_DB_NAME}" ] ; then
			dbc_dbuser=${PARSED_USER}
			dbc_dbpass=${PARSED_PASS}
			dbc_dbserver=${PARSED_SERVER}
			dbc_dbport=${PARSED_PORT}
			dbc_dbname=${PARSED_DB_NAME}
		fi
		if [ "${PARSED_DB_TYPE}" = "mysql" ] ; then
			dbc_dbtypes="mysql, pgsql, sqlite3"
		else
			dbc_dbtypes="pgsql, mysql, sqlite3"
		fi
		db_authmethod_user="password"
	fi
	dbc_go keystone $@
fi
