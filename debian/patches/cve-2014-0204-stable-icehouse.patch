Description: SQL and LDAP fixes for get_roles_for_user_and_project user=group ID
 When there was a role assigned to a group with the same ID as a user, the SQL
 assignment backend would incorrectly return the assignment to the group when
 requesting roles for the user via the get_roles_for_user_and_project method.
 .
 With this change, assignments to a group with the same ID are not returned for
 the user when calling get_roles_for_user_and_project.
 .
 Added a test to show what the assignment manager's
 get_roles_for_user_and_project() method returned when there's a group with the
 same ID as a user and only the group is granted a role on the project.
Author: Brant Knudson <bknudson@us.ibm.com>
Date: Mon, 28 Apr 2014 12:20:47 -0500
Bug-Ubuntu: https://launchpad.net/bugs/1309228
Change-Id: I88909d68d035cf48315c3249234a5dc24cbb4a5f

Index: keystone/keystone/assignment/backends/ldap.py
===================================================================
--- keystone.orig/keystone/assignment/backends/ldap.py	2014-05-04 23:08:56.000000000 +0800
+++ keystone/keystone/assignment/backends/ldap.py	2014-05-09 23:56:36.000000000 +0800
@@ -88,24 +88,54 @@
 
         def _get_roles_for_just_user_and_project(user_id, tenant_id):
             self.get_project(tenant_id)
-            return [self.role._dn_to_id(a.role_dn)
-                    for a in self.role.get_role_assignments
-                    (self.project._id_to_dn(tenant_id))
-                    if self.user._dn_to_id(a.user_dn) == user_id]
+
+            proj_dn = self.project._id_to_dn(tenant_id)
+            assignments = self.role.get_role_assignments(proj_dn)
+
+            roles = []
+            for assignment in assignments:
+                assignment_id = self.user._dn_to_id(assignment.user_dn)
+
+                if assignment_id != user_id:
+                    # Skip this assignment, it's not the target user id.
+                    continue
+
+                # "normalize" DN by uppercase, then see if the entry is in the
+                # tree by checking if the entry DN ends with the tree DN.
+                assignment_dn_norm = assignment.user_dn.upper()
+                user_tree_dn_norm = self.user.tree_dn.upper()
+                if not assignment_dn_norm.endswith(user_tree_dn_norm):
+                    # Skip this assignment, it's not a user assignment.
+                    continue
+
+                role_id = self.role._dn_to_id(assignment.role_dn)
+                roles.append(role_id)
+            return roles
 
         def _get_roles_for_group_and_project(group_id, project_id):
             self.get_project(project_id)
-            group_dn = self.group._id_to_dn(group_id)
-            # NOTE(marcos-fermin-lobo): In Active Directory, for functions
-            # such as "self.role.get_role_assignments", it returns
-            # the key "CN" or "OU" in uppercase.
-            # The group_dn var has "CN" and "OU" in lowercase.
-            # For this reason, it is necessary to use the "upper()"
-            # function so both are consistent.
-            return [self.role._dn_to_id(a.role_dn)
-                    for a in self.role.get_role_assignments
-                    (self.project._id_to_dn(project_id))
-                    if a.user_dn.upper() == group_dn.upper()]
+
+            project_dn = self.project._id_to_dn(project_id)
+            assignments = self.role.get_role_assignments(project_dn)
+
+            roles = []
+            for assignment in assignments:
+                assignment_id = self.group._dn_to_id(assignment.user_dn)
+
+                if assignment_id != group_id:
+                    # Skip this assignment, it's not the target group id.
+                    continue
+
+                # "normalize" DN by uppercase, then see if the entry is in the
+                # tree by checking if the entry DN ends with the tree DN.
+                assignment_dn_norm = assignment.user_dn.upper()
+                group_tree_dn_norm = self.group.tree_dn.upper()
+                if not assignment_dn_norm.endswith(group_tree_dn_norm):
+                    # Skip this assignment, it's not a group assignment.
+                    continue
+
+                roles.append(self.role._dn_to_id(assignment.role_dn))
+            return roles
 
         if domain_id is not None:
             msg = _('Domain metadata not supported by LDAP')
Index: keystone/keystone/assignment/backends/sql.py
===================================================================
--- keystone.orig/keystone/assignment/backends/sql.py	2014-05-04 23:08:56.000000000 +0800
+++ keystone/keystone/assignment/backends/sql.py	2014-05-09 23:56:36.000000000 +0800
@@ -86,6 +86,21 @@
             session = sql.get_session()
 
         q = session.query(RoleAssignment)
+
+        def _calc_assignment_type():
+            # Figure out the assignment type we're checking for from the args.
+            if user_id:
+                if tenant_id:
+                    return AssignmentType.USER_PROJECT
+                else:
+                    return AssignmentType.USER_DOMAIN
+            else:
+                if tenant_id:
+                    return AssignmentType.GROUP_PROJECT
+                else:
+                    return AssignmentType.GROUP_DOMAIN
+
+        q = q.filter_by(type=_calc_assignment_type())
         q = q.filter_by(actor_id=user_id or group_id)
         q = q.filter_by(target_id=tenant_id or domain_id)
         refs = q.all()
Index: keystone/keystone/tests/test_backend.py
===================================================================
--- keystone.orig/keystone/tests/test_backend.py	2014-05-04 23:08:56.000000000 +0800
+++ keystone/keystone/tests/test_backend.py	2014-05-09 23:56:36.000000000 +0800
@@ -1377,6 +1377,43 @@
         self.assertIn(role_list[1]['id'], combined_role_list)
         self.assertIn(role_list[2]['id'], combined_role_list)
 
+    def test_get_roles_for_user_and_project_user_group_same_id(self):
+        """When a user has the same ID as a group,
+        get_roles_for_user_and_project returns only the roles for the user and
+        not the group.
+
+        """
+
+        # Setup: create user, group with same ID, role, and project;
+        # assign the group the role on the project.
+
+        user_group_id = uuid.uuid4().hex
+
+        user1 = {'id': user_group_id, 'name': uuid.uuid4().hex,
+                 'domain_id': DEFAULT_DOMAIN_ID, }
+        self.identity_api.create_user(user_group_id, user1)
+
+        group1 = {'id': user_group_id, 'name': uuid.uuid4().hex,
+                  'domain_id': DEFAULT_DOMAIN_ID, }
+        self.identity_api.create_group(user_group_id, group1)
+
+        role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}
+        self.assignment_api.create_role(role1['id'], role1)
+
+        project1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex,
+                    'domain_id': DEFAULT_DOMAIN_ID, }
+        self.assignment_api.create_project(project1['id'], project1)
+
+        self.assignment_api.create_grant(role1['id'],
+                                         group_id=user_group_id,
+                                         project_id=project1['id'])
+
+        # Check the roles, shouldn't be any since the user wasn't granted any.
+        roles = self.assignment_api.get_roles_for_user_and_project(
+            user_group_id, project1['id'])
+
+        self.assertEqual([], roles, 'role for group is %s' % role1['id'])
+
     def test_delete_role_with_user_and_group_grants(self):
         role1 = {'id': uuid.uuid4().hex, 'name': uuid.uuid4().hex}
         self.assignment_api.create_role(role1['id'], role1)
