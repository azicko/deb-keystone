Description: Limit calls to memcache backend as user token index increases
 in size. 
 This eliminates the need to do a get on each token in the user's index
 on token issuance. This change will change the maximum number of tokens
 that can be outstanding for a given user. This change is two-fold, first
 instead of using JSON to store the token IDs, the python list structure
 is being stored in memcached; second the expiry for the token is also
 stored in the list.
 .
 A flush of the user-token-lists will occur on first issuance of a new
 token since the underlying format has changed. To all external consumers
 the token list will remain unchanged, the expiry is only presented to the
 token backend driver for housekeeping purposes.
 Fix default catalog so that it matches the region name which is set by
 default by debconf in all of the Openstack Debian packages.
Author: gustavo panizzo <gfa@zumbi.com.ar>
Forwarded: not-needed
Last-Update: 2014-01-13
Author: Morgan Fainberg <m@metacloud.com>
Bug-Ubuntu: https://launchpad.net/bugs/1251123
Origin: https://review.openstack.org/#/c/66149/

--- a/keystone/tests/test_backend_memcache.py
+++ b/keystone/tests/test_backend_memcache.py
@@ -23,7 +23,6 @@ import memcache
 from keystone.common import utils
 from keystone import config
 from keystone import exception
-from keystone.openstack.common import jsonutils
 from keystone.openstack.common import timeutils
 from keystone import tests
 from keystone.tests import test_backend
@@ -163,30 +162,31 @@ class MemcacheToken(tests.TestCase, test_backend.TokenTests):
         # get expired tokens as well as valid tokens. token_api.list_tokens()
         # will not return any expired tokens in the list.
         user_key = self.token_api.driver._prefix_user_id(user_id)
-        user_record = self.token_api.driver.client.get(user_key)
-        user_token_list = jsonutils.loads('[%s]' % user_record)
+        user_token_list = self.token_api.driver.client.get(user_key)
         self.assertEquals(len(user_token_list), 2)
-        expired_token_ptk = self.token_api.driver._prefix_token_id(
-            expired_token_id)
-        expired_token = self.token_api.driver.client.get(expired_token_ptk)
-        expired_token['expires'] = (timeutils.utcnow() - expire_delta)
-        self.token_api.driver.client.set(expired_token_ptk, expired_token)
+        # Tokens are not fetched again on token issuance, expiry is held in the
+        # user token index record as the second element.
+        expired_idx = [i[0] for i in user_token_list].index(expired_token_id)
+        user_token_list[expired_idx] = (user_token_list[expired_idx][0],
+                                        timeutils.utcnow() - expire_delta)
+        self.token_api.driver.client.set(user_key, user_token_list)
 
         self.token_api.create_token(second_valid_token_id, second_valid_data)
-        user_record = self.token_api.driver.client.get(user_key)
-        user_token_list = jsonutils.loads('[%s]' % user_record)
+        user_token_list = self.token_api.driver.client.get(user_key)
         self.assertEquals(len(user_token_list), 2)
 
     def test_cas_failure(self):
+        expire_delta = datetime.timedelta(seconds=86400)
         self.token_api.driver.client.reject_cas = True
         token_id = uuid.uuid4().hex
         user_id = unicode(uuid.uuid4().hex)
+        token_data = {'expires': timeutils.utcnow() + expire_delta,
+                      'id': token_id}
         user_key = self.token_api.driver._prefix_user_id(user_id)
-        token_data = jsonutils.dumps(token_id)
         self.assertRaises(
             exception.UnexpectedError,
             self.token_api.driver._update_user_list_with_cas,
-            user_key, token_data)
+            user_key, token_id, token_data)
 
     def test_token_expire_timezone(self):
 
diff --git a/keystone/token/backends/memcache.py b/keystone/token/backends/memcache.py
index 2582c49..54dcaa0 100644
--- a/keystone/token/backends/memcache.py
+++ b/keystone/token/backends/memcache.py
@@ -83,15 +83,14 @@ class Token(token.Driver):
             kwargs['time'] = expires_ts
         self.client.set(ptk, data_copy, **kwargs)
         if 'id' in data['user']:
-            token_data = jsonutils.dumps(token_id)
             user_id = data['user']['id']
             user_key = self._prefix_user_id(user_id)
             # Append the new token_id to the token-index-list stored in the
             # user-key within memcache.
-            self._update_user_list_with_cas(user_key, token_data)
+            self._update_user_list_with_cas(user_key, token_id, data_copy)
         return copy.deepcopy(data_copy)
 
-    def _update_user_list_with_cas(self, user_key, token_id):
+    def _update_user_list_with_cas(self, user_key, token_id, token_data):
         cas_retry = 0
         max_cas_retry = CONF.memcache.max_compare_and_set_retry
         current_time = timeutils.normalize_time(
@@ -110,35 +109,31 @@ class Token(token.Driver):
             # case memcache is down or something horrible happens we don't
             # iterate forever trying to compare and set the new value.
             cas_retry += 1
-            record = self.client.gets(user_key)
+            token_list = self.client.gets(user_key)
             filtered_list = []
 
-            if record is not None:
-                token_list = jsonutils.loads('[%s]' % record)
-                for token_i in token_list:
-                    ptk = self._prefix_token_id(token_i)
-                    token_ref = self.client.get(ptk)
-                    if not token_ref:
-                        # skip tokens that do not exist in memcache
+            if token_list is not None:
+                if not isinstance(token_list, list):
+                    LOG.error(_('Resetting non-list user token index record: '
+                                '%s'), user_key)
+                    token_list = []
+                for token_i, expiry in token_list:
+                    expires_at = timeutils.normalize_time(expiry)
+                    if expires_at < current_time:
+                        # skip tokens that are expired.
                         continue
 
-                    if 'expires' in token_ref:
-                        expires_at = timeutils.normalize_time(
-                            token_ref['expires'])
-                        if expires_at < current_time:
-                            # skip tokens that are expired.
-                            continue
-
                     # Add the still valid token_id to the list.
-                    filtered_list.append(jsonutils.dumps(token_i))
-            # Add the new token_id to the list.
-            filtered_list.append(token_id)
+                    filtered_list.append((token_i, expiry))
+            # Add the new token_id and expiry.
+            filtered_list.append(
+                (token_id, timeutils.normalize_time(token_data['expires'])))
 
             # Use compare-and-set (cas) to set the new value for the
             # token-index-list for the user-key. Cas is used to prevent race
             # conditions from causing the loss of valid token ids from this
             # list.
-            if self.client.cas(user_key, ','.join(filtered_list)):
+            if self.client.cas(user_key, filtered_list):
                 msg = _('Successful set of token-index-list for user-key '
                         '"%(user_key)s", #%(count)d records')
                 LOG.debug(msg, {'user_key': user_key,
@@ -182,9 +177,18 @@ class Token(token.Driver):
                     consumer_id=None):
         tokens = []
         user_key = self._prefix_user_id(user_id)
-        user_record = self.client.get(user_key) or ""
-        token_list = jsonutils.loads('[%s]' % user_record)
-        for token_id in token_list:
+        current_time = timeutils.normalize_time(
+            timeutils.parse_isotime(timeutils.isotime()))
+        token_list = self.client.get(user_key) or []
+        if not isinstance(token_list, list):
+            # NOTE(morganfainberg): This is for compatibility for old-format
+            # token-lists that were a JSON string of just token_ids. This code
+            # will reference the underlying expires directly from the
+            # token_ref vs in this list, so setting to none just ensures the
+            # loop works as expected.
+            token_list = [(i, None) for i in
+                          jsonutils.loads('[%s]' % token_list)]
+        for token_id, expiry in token_list:
             ptk = self._prefix_token_id(token_id)
             token_ref = self.client.get(ptk)
             if token_ref:
@@ -208,6 +212,11 @@ class Token(token.Driver):
                     except KeyError:
                         continue
 
+                if (timeutils.normalize_time(token_ref['expires']) <
+                        current_time):
+                    # Skip expired tokens.
+                    continue
+
                 tokens.append(token_id)
         return tokens
 
-- 
1.8.4.3

